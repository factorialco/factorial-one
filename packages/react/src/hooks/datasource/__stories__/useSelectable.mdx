import { Meta } from "@storybook/addon-docs/blocks"

<Meta title="Datasource/useSelectable" />

# useSelectable

The `useSelectable` hook manages selection state for individual items and groups
in a data collection. It provides comprehensive selection functionality
including individual item selection, group selection with cascading, bulk
operations support, and partial selection states.

## Overview

`useSelectable` handles the complex logic of managing selection state in data
collections, including:

- Individual item selection and deselection
- Group selection with automatic cascading to items
- Bulk selection operations (select all/none)
- Partial selection states (indeterminate checkboxes)
- Default selected items configuration
- Integration with pagination and filtering

### Key Features

- **Individual Selection**: Select/deselect individual items
- **Group Selection**: Select/deselect entire groups with cascading
- **Partial States**: Indeterminate checkbox states for partial selections
- **Default Selection**: Support for pre-selected items and groups
- **Pagination Aware**: Works correctly with paginated data
- **Type Safe**: Full TypeScript support with generics

## API Reference

### Parameters

```tsx
useSelectable<R, Filters, Sortings, Summaries, ItemActions, NavigationFilters, Grouping>(
  data: Data<R>,
  paginationInfo: PaginationInfo | null,
  source: DataSource<R, Filters, Sortings, Summaries, ItemActions, NavigationFilters, Grouping>,
  onSelectItems?: OnSelectItemsCallback<R, Filters>,
  defaultSelectedItems?: SelectedItemsState
)
```

### Parameters

#### `data: Data<R>`

The data object returned by `useData`, containing records and groups.

#### `paginationInfo: PaginationInfo | null`

Pagination information from `useData` to handle selection across pages.

#### `source: DataSource`

The data source object from `useDataSource` containing configuration.

#### `onSelectItems?: OnSelectItemsCallback<R, Filters>`

Optional callback triggered when selection changes:

```tsx
type OnSelectItemsCallback<R, Filters> = (
  allItemsCheck: boolean | "indeterminate",
  selectedItems: {
    items: Array<{ id: string | number; checked: boolean }>
    groups: Array<{ groupId: string; checked: boolean }>
  },
  filters: FiltersState<Filters>
) => void
```

#### `defaultSelectedItems?: SelectedItemsState`

Default selected items and groups:

```tsx
type SelectedItemsState = {
  items?: Array<{ id: string | number; checked: boolean }>
  groups?: Array<{ groupId: string; checked: boolean }>
}
```

### Return Value

```tsx
interface UseSelectable<R> {
  // Selection State
  selectedItems: Map<number | string, R> // Currently selected items
  selectedGroups: Map<string, GroupRecord<R>> // Currently selected groups

  // Selection Status
  isAllSelected: boolean // Are all items selected?
  isPartiallySelected: boolean // Are some items selected?
  allSelectedStatus: AllSelectionStatus // Overall selection status
  groupAllSelectedStatus: Record<string, AllSelectionStatus> // Per-group status

  // Selection Actions
  handleSelectItemChange: (item: R, checked: boolean) => void // Select/deselect item
  handleSelectAll: (checked: boolean) => void // Select/deselect all
  handleSelectGroupChange: (group: GroupRecord<R>, checked: boolean) => void // Select/deselect group
}
```

### Selection Status Types

```tsx
interface AllSelectionStatus {
  checked: boolean // All items selected
  indeterminate: boolean // Some items selected
  selectedCount: number // Number of selected items
  unselectedCount: number // Number of unselected items
}
```

## Usage Examples

### Basic Selection

```tsx
import { useDataSource, useData, useSelectable } from "@/hooks/datasource"

function SelectableUserList() {
  const dataSource = useDataSource({
    filters: userFilters,
    selectable: (user) => user.id, // Enable selection by ID
    dataAdapter: { fetchData: fetchUsers },
  })

  const { data, paginationInfo } = useData(dataSource)

  const {
    selectedItems,
    handleSelectItemChange,
    handleSelectAll,
    isAllSelected,
    isPartiallySelected,
  } = useSelectable(data, paginationInfo, dataSource)

  return (
    <div>
      {/* Select All checkbox */}
      <label>
        <input
          type="checkbox"
          checked={isAllSelected}
          ref={(el) => {
            if (el) el.indeterminate = isPartiallySelected && !isAllSelected
          }}
          onChange={(e) => handleSelectAll(e.target.checked)}
        />
        Select All ({selectedItems.size} selected)
      </label>

      {/* Individual items */}
      {data.records.map((user) => (
        <div key={user.id}>
          <label>
            <input
              type="checkbox"
              checked={selectedItems.has(user.id)}
              onChange={(e) => handleSelectItemChange(user, e.target.checked)}
            />
            {user.name}
          </label>
        </div>
      ))}
    </div>
  )
}
```

### Group Selection

```tsx
function GroupedSelectableUserList() {
  const dataSource = useDataSource({
    filters: userFilters,
    selectable: (user) => user.id,
    grouping: {
      groupBy: {
        department: {
          label: "Department",
          getGroupKey: (user) => user.department,
          getGroupLabel: (key) => key.charAt(0).toUpperCase() + key.slice(1),
        },
      },
    },
    currentGrouping: { field: "department", order: "asc" },
    dataAdapter: { fetchData: fetchUsers },
  })

  const { data, paginationInfo } = useData(dataSource)

  const {
    selectedItems,
    selectedGroups,
    handleSelectItemChange,
    handleSelectGroupChange,
    groupAllSelectedStatus,
  } = useSelectable(data, paginationInfo, dataSource)

  if (data.type !== "grouped") return null

  return (
    <div>
      {data.groups.map((group) => {
        const groupStatus = groupAllSelectedStatus[group.key]

        return (
          <div key={group.key}>
            {/* Group header with selection */}
            <div className="group-header">
              <label>
                <input
                  type="checkbox"
                  checked={groupStatus?.checked || false}
                  ref={(el) => {
                    if (el)
                      el.indeterminate = groupStatus?.indeterminate || false
                  }}
                  onChange={(e) =>
                    handleSelectGroupChange(group, e.target.checked)
                  }
                />
                <h3>
                  {group.label} ({groupStatus?.selectedCount || 0}/
                  {group.itemCount})
                </h3>
              </label>
            </div>

            {/* Group items */}
            {group.records.map((user) => (
              <div key={user.id} className="group-item">
                <label>
                  <input
                    type="checkbox"
                    checked={selectedItems.has(user.id)}
                    onChange={(e) =>
                      handleSelectItemChange(user, e.target.checked)
                    }
                  />
                  {user.name}
                </label>
              </div>
            ))}
          </div>
        )
      })}
    </div>
  )
}
```

### Default Selected Items

```tsx
function UserListWithDefaults() {
  const dataSource = useDataSource({
    filters: userFilters,
    selectable: (user) => user.id,
    defaultSelectedItems: {
      items: [
        { id: "user1", checked: true },
        { id: "user2", checked: true },
      ],
      groups: [{ groupId: "engineering", checked: true }],
    },
    dataAdapter: { fetchData: fetchUsers },
  })

  const { data, paginationInfo } = useData(dataSource)

  const { selectedItems, handleSelectItemChange, handleSelectAll } =
    useSelectable(
      data,
      paginationInfo,
      dataSource,
      undefined,
      dataSource.defaultSelectedItems
    )

  return (
    <div>
      {/* Default items are already selected */}
      {data.records.map((user) => (
        <div key={user.id}>
          <label>
            <input
              type="checkbox"
              checked={selectedItems.has(user.id)}
              onChange={(e) => handleSelectItemChange(user, e.target.checked)}
            />
            {user.name}
          </label>
        </div>
      ))}
    </div>
  )
}
```

### Selection with Callback

```tsx
function UserListWithCallback() {
  const dataSource = useDataSource({
    filters: userFilters,
    selectable: (user) => user.id,
    dataAdapter: { fetchData: fetchUsers },
  })

  const { data, paginationInfo } = useData(dataSource)

  const handleSelectionChange = useCallback(
    (
      allItemsCheck: boolean | "indeterminate",
      selectedItems: {
        items: Array<{ id: string | number; checked: boolean }>
        groups: Array<{ groupId: string; checked: boolean }>
      },
      filters: FiltersState<typeof userFilters>
    ) => {
      console.log("Selection changed:", {
        allItemsCheck,
        selectedItems,
        filters,
      })

      // For async data collections, you might need to handle selection differently
      if (allItemsCheck === true || allItemsCheck === "indeterminate") {
        // Apply selection to all items matching current filters
        // This would typically be done on the backend
      }
    },
    []
  )

  const { selectedItems, handleSelectItemChange, handleSelectAll } =
    useSelectable(data, paginationInfo, dataSource, handleSelectionChange)

  return (
    <div>
      {data.records.map((user) => (
        <div key={user.id}>
          <label>
            <input
              type="checkbox"
              checked={selectedItems.has(user.id)}
              onChange={(e) => handleSelectItemChange(user, e.target.checked)}
            />
            {user.name}
          </label>
        </div>
      ))}
    </div>
  )
}
```

### Paginated Selection

```tsx
function PaginatedSelectableUserList() {
  const dataSource = useDataSource({
    filters: userFilters,
    selectable: (user) => user.id,
    dataAdapter: {
      paginationType: "pages",
      perPage: 10,
      fetchData: fetchUsers,
    },
  })

  const { data, paginationInfo, setPage } = useData(dataSource)

  const {
    selectedItems,
    handleSelectItemChange,
    handleSelectAll,
    allSelectedStatus,
  } = useSelectable(data, paginationInfo, dataSource)

  return (
    <div>
      {/* Selection persists across pages */}
      <div className="selection-info">
        <span>
          {allSelectedStatus.selectedCount} of {paginationInfo?.total} items
          selected
        </span>
        <button onClick={() => handleSelectAll(false)}>Clear Selection</button>
      </div>

      {/* Current page items */}
      {data.records.map((user) => (
        <div key={user.id}>
          <label>
            <input
              type="checkbox"
              checked={selectedItems.has(user.id)}
              onChange={(e) => handleSelectItemChange(user, e.target.checked)}
            />
            {user.name}
          </label>
        </div>
      ))}

      {/* Pagination controls */}
      {paginationInfo && (
        <div className="pagination">
          <button
            onClick={() => setPage(paginationInfo.currentPage - 1)}
            disabled={paginationInfo.currentPage === 1}
          >
            Previous
          </button>
          <span>
            Page {paginationInfo.currentPage} of {paginationInfo.pagesCount}
          </span>
          <button
            onClick={() => setPage(paginationInfo.currentPage + 1)}
            disabled={paginationInfo.currentPage === paginationInfo.pagesCount}
          >
            Next
          </button>
        </div>
      )}
    </div>
  )
}
```
