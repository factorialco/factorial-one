import { Meta } from "@storybook/addon-docs/blocks"
import LinkTo from "@storybook/addon-links/react"

<Meta title="Datasource" />

# Datasource Hooks

The `@/hooks/datasource` package provides a comprehensive set of React hooks for
managing data collection state, including filtering, sorting, searching,
pagination, grouping, and selection.

{/* prettier-ignore */}
> If your are looking for the `OneDataCollection` component, please refer to the  <LinkTo kind="Components/Data Collection" story="Documentation">OneDataCollection</LinkTo>
> documentation. as this hooks, even if it's compatible with the 
> `OneDataCollection` component, it does not provide all the features of the
> `OneDataCollection` component.

## Overview

The datasource hooks follow a layered architecture that separates concerns:

1. **Configuration & State Management** (`useDataSource`) - Manages all the
   configuration and state for filters, search, sorting, navigation filters, and
   grouping
2. **Data Fetching** (`useData`) - Handles the actual data fetching, loading
   states, and pagination
3. **Selection Management** (`useSelectable`) - Manages item and group selection
   state
4. **Group Management** (`useGroups`) - Manages group expand/collapse state

## Why Separate Hooks?

The hooks were extracted from `OneDataCollection` for several key reasons:

### üîÑ **Reusability**

- Use the same data source logic across multiple components
- Share state between different visualizations (tables, cards, charts)
- Build custom components that leverage the same data management patterns

### üéØ **Separation of Concerns**

- **Data Management**: Handled by datasource hooks
- **UI Rendering**: Handled by visualization components
- **Business Logic**: Encapsulated in data adapters

### üîß **Flexibility**

- Different visualizations can customize data fetching (e.g., grid-friendly
  pagination)
- Mix and match hooks based on component needs
- Easy to extend with new functionality

## Core Hooks

### [useDataSource](/?path=/docs/hooks-datasource-usedatasource--docs)

Creates and manages a data source with comprehensive state management for
filters, search, sorting, navigation filters, and grouping.

```tsx
const dataSource = useDataSource({
  filters: {
    /* filter definitions */
  },
  dataAdapter: {
    /* data fetching logic */
  },
  sortings: {
    /* sorting definitions */
  },
  search: { enabled: true },
  grouping: {
    /* grouping definitions */
  },
  currentFilters: {
    /* initial filter state */
  },
  currentGrouping: {
    /* initial grouping state */
  },
  currentSearch: "" // initial search value,
  defaultSorting: {
    field: "name", // default sorting field
    order: "asc",
  },
})
```

### [useData](/?path=/docs/hooks-datasource-usedata--docs)

Handles data fetching, loading states, and pagination. Consumes a data source
and provides the actual data.

```tsx
const { data, isLoading, paginationInfo, setPage } = useData(dataSource)
```

### [useSelectable](/?path=/docs/hooks-datasource-useselectable--docs)

Manages selection state for individual items and groups, with support for bulk
operations.

```tsx
const {
  selectedItems,
  handleSelectItemChange,
  handleSelectAll,
  isAllSelected,
} = useSelectable(data, paginationInfo, dataSource, onSelectItems)
```

### [useGroups](/?path=/docs/hooks-datasource-usegroups--docs)

Manages group expand/collapse state with support for default open states and
animations.

```tsx
const { openGroups, setGroupOpen } = useGroups(data.groups, defaultOpenGroups)
```

## Usage Patterns

### Basic Data Collection

```tsx
function MyDataCollection() {
  const dataSource = useDataSource({
    dataAdapter: { fetchData: myFetchFunction },
    filters: myFilters,
    currentFilters: {
      name: "John",
    },
    currentGrouping: {
      field: "name",
      order: "asc",
    },
    currentSearch: "John",
    defaultSorting: {
      field: "name",
      order: "asc",
    },
  })

  const { data, isLoading } = useData(dataSource)

  if (isLoading) return <Loading />

  return (
    <div>
      {data.records.map((record) => (
        <div key={record.id}>{record.name}</div>
      ))}
    </div>
  )
}
```

### Multi-Visualization Setup

```tsx
function Dashboard() {
  const dataSource = useDataSource({
    dataAdapter: { fetchData: myFetchFunction },
    filters: myFilters,
  })

  return (
    <div>
      <TableView source={dataSource} />
      <ChartView source={dataSource} />
      <CardView source={dataSource} />
    </div>
  )
}
```

### Custom Data Adapter

```tsx
const customDataSource = useDataSource({
  dataAdapter: {
    paginationType: "pages",
    perPage: 20,
    fetchData: async ({ filters, pagination }) => {
      const response = await fetch("/api/data", {
        method: "POST",
        body: JSON.stringify({ filters, ...pagination }),
      })
      return response.json()
    },
  },
})
```

## Key Features

### üîç **Filtering & Search**

- Support for multiple filter types (text, select, date, etc.)
- Debounced search with customizable delay
- Navigation filters for different UI contexts
- Filter presets for common configurations

### üìä **Sorting & Grouping**

- Multi-column sorting with customizable definitions
- Hierarchical grouping with expand/collapse
- Mandatory and optional grouping modes
- Custom group labeling and item counting

### üìÑ **Pagination**

- Page-based pagination with page numbers
- Infinite scroll with cursor-based loading
- Customizable page sizes
- Automatic pagination type detection

### ‚úÖ **Selection**

- Individual item selection
- Group selection with cascading
- Bulk operations support
- Partial selection states (indeterminate)

### üîÑ **Data Sources**

- Synchronous data arrays
- Promise-based async data
- Observable streams for real-time updates
- Automatic loading state management

## TypeScript Support

All hooks are fully typed with generic support for:

- Record types
- Filter configurations
- Action definitions
- Sorting configurations
- Grouping configurations

```tsx
type MyRecord = {
  id: string
  name: string
  department: string
}

type MyFilters = {
  department: FilterDefinition<"select", string[]>
  search: FilterDefinition<"text", string>
}

const dataSource = useDataSource<MyRecord, MyFilters>({
  // Fully typed configuration
})
```

## Getting Started

1. **Choose your hooks** based on your component needs
2. **Configure your data source** with `useDataSource`
3. **Fetch data** with `useData`
4. **Add selection** with `useSelectable` (optional)
5. **Manage groups** with `useGroups` (optional)

For detailed examples and API references, see the individual hook documentation
linked above.
