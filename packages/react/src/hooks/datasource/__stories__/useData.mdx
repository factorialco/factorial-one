import { Meta } from "@storybook/addon-docs/blocks"

<Meta title="Datasource/useData" />

# useData

The `useData` hook handles data fetching, state management, and pagination
within the Collections ecosystem. It consumes a data source created by
`useDataSource` and provides the actual data along with loading states and
pagination controls.

## Overview

`useData` is a core React hook that manages data fetching and state management.
It exists as a separate hook to enable visualization-specific customization
while maintaining consistent data fetching patterns across different components.

### Why a Separate Hook?

1. **Visualization-Specific Needs**: Different visualizations have unique data
   requirements (e.g., grid-aligned pagination for cards, row-optimized for
   tables)
2. **Separation of Concerns**: Clear boundaries between data source
   configuration and data fetching
3. **Extensibility**: New visualizations can customize data consumption without
   modifying core logic

### Key Features

- **Multi-Source Support**: Handles synchronous data, Promises, and Observables
- **Pagination Management**: Automatic page handling with state management
- **Loading States**: Consistent loading states (`isInitialLoading`,
  `isLoading`, `isLoadingMore`)
- **Error Handling**: Standardized error handling with detailed error
  information
- **Automatic Cleanup**: Prevents memory leaks by cleaning up subscriptions
- **Data Transformation**: Supports grouped and flat data structures

## API Reference

### Parameters

```tsx
useData<R, Filters, Sortings, Summaries, NavigationFilters, Grouping>(
  source: DataSource<R, Filters, Sortings, Summaries, ItemActions, NavigationFilters, Grouping>,
  options?: UseDataOptions<Filters>
)
```

### Parameters

#### `source: DataSource`

The data source object created by `useDataSource`. Contains all configuration
and state management for data fetching.

#### `options?: UseDataOptions<Filters>`

Optional configuration object:

```tsx
interface UseDataOptions<Filters> {
  filters?: Partial<FiltersState<Filters>> // Override current filters
  onError?: (error: DataError) => void // Error handling callback
}
```

### Return Value

```tsx
interface UseDataReturn<R> {
  // Data
  data: Data<R> // Current data with records and groups
  summaries?: R // Summary data if available

  // Loading States
  isInitialLoading: boolean // First load indicator
  isLoading: boolean // Any loading indicator
  isLoadingMore: boolean // Loading more data (infinite scroll)

  // Error Handling
  error: DataError | null // Current error state

  // Pagination
  paginationInfo: PaginationInfo | null // Pagination metadata
  totalItems: number | undefined // Total items count

  // Pagination Controls
  setPage: (page: number) => void // For page-based pagination
  loadMore: () => void // For infinite scroll pagination
}
```

### Data Structure

#### `Data<R>`

The main data structure returned by the hook:

```tsx
type Data<R> = {
  records: WithGroupId<R>[] // All records with optional group IDs
  type: "grouped" | "flat" // Data organization type
  groups: GroupRecord<WithGroupId<R>>[] // Group information (empty for flat)
}
```

#### `GroupRecord<R>`

For grouped data, each group contains:

```tsx
type GroupRecord<R> = {
  key: string // Unique group identifier
  label: string | Promise<string> // Group display label
  itemCount: number | undefined | Promise<number | undefined> // Items in group
  records: R[] // Group records
}
```

#### `DataError`

Error information structure:

```tsx
interface DataError {
  message: string // Error message
  cause?: unknown // Original error cause
}
```

## Usage Examples

### Basic Usage

```tsx
import { useDataSource, useData } from "@/hooks/datasource"

function UserList() {
  const dataSource = useDataSource({
    filters: userFilters,
    dataAdapter: {
      fetchData: async ({ filters }) => {
        const response = await fetch("/api/users", {
          method: "POST",
          body: JSON.stringify({ filters }),
        })
        return response.json()
      },
    },
  })

  const { data, isLoading, error } = useData(dataSource)

  if (isLoading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return (
    <div>
      {data.records.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  )
}
```

### Paginated Data

```tsx
function PaginatedUserList() {
  const dataSource = useDataSource({
    filters: userFilters,
    dataAdapter: {
      paginationType: "pages",
      perPage: 20,
      fetchData: async ({ filters, pagination }) => {
        const response = await fetch("/api/users", {
          method: "POST",
          body: JSON.stringify({
            filters,
            page: pagination.currentPage,
            perPage: pagination.perPage,
          }),
        })
        return response.json()
      },
    },
  })

  const { data, isLoading, paginationInfo, setPage } = useData(dataSource)

  return (
    <div>
      {/* Data display */}
      {data.records.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}

      {/* Pagination controls */}
      {paginationInfo && (
        <div>
          <button
            onClick={() => setPage(paginationInfo.currentPage - 1)}
            disabled={paginationInfo.currentPage === 1}
          >
            Previous
          </button>
          <span>
            Page {paginationInfo.currentPage} of {paginationInfo.pagesCount}
          </span>
          <button
            onClick={() => setPage(paginationInfo.currentPage + 1)}
            disabled={paginationInfo.currentPage === paginationInfo.pagesCount}
          >
            Next
          </button>
        </div>
      )}
    </div>
  )
}
```

### Infinite Scroll

```tsx
function InfiniteUserList() {
  const dataSource = useDataSource({
    filters: userFilters,
    dataAdapter: {
      paginationType: "infinite-scroll",
      perPage: 20,
      fetchData: async ({ filters, pagination }) => {
        const response = await fetch("/api/users", {
          method: "POST",
          body: JSON.stringify({
            filters,
            cursor: pagination.cursor,
            perPage: pagination.perPage,
          }),
        })
        return response.json()
      },
    },
  })

  const { data, isLoading, isLoadingMore, loadMore, paginationInfo } =
    useData(dataSource)

  return (
    <div>
      {data.records.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}

      {paginationInfo?.hasMore && (
        <button onClick={loadMore} disabled={isLoadingMore}>
          {isLoadingMore ? "Loading..." : "Load More"}
        </button>
      )}
    </div>
  )
}
```

### Grouped Data

```tsx
function GroupedUserList() {
  const dataSource = useDataSource({
    filters: userFilters,
    grouping: {
      groupBy: {
        department: {
          label: "Department",
          getGroupKey: (user) => user.department,
          getGroupLabel: (key) => key.charAt(0).toUpperCase() + key.slice(1),
        },
      },
    },
    currentGrouping: { field: "department", order: "asc" },
    dataAdapter: {
      fetchData: async ({ filters }) => {
        const response = await fetch("/api/users", {
          method: "POST",
          body: JSON.stringify({ filters }),
        })
        return response.json()
      },
    },
  })

  const { data, isLoading } = useData(dataSource)

  if (isLoading) return <div>Loading...</div>

  return (
    <div>
      {data.type === "grouped"
        ? data.groups.map((group) => (
            <div key={group.key}>
              <h3>
                {group.label} ({group.itemCount})
              </h3>
              {group.records.map((user) => (
                <div key={user.id}>{user.name}</div>
              ))}
            </div>
          ))
        : data.records.map((user) => <div key={user.id}>{user.name}</div>)}
    </div>
  )
}
```

### Observable Data Source

```tsx
import { Observable } from "zen-observable-ts"

function RealtimeUserList() {
  const dataSource = useDataSource({
    filters: userFilters,
    dataAdapter: {
      fetchData: ({ filters }) => {
        return new Observable((observer) => {
          observer.next({ type: "loading", data: undefined })

          const subscription = userService.subscribe(
            filters,
            (data) => {
              observer.next({ type: "success", data })
            },
            (error) => {
              observer.next({ type: "error", error })
            }
          )

          return () => subscription.unsubscribe()
        })
      },
    },
  })

  const { data, isLoading, error } = useData(dataSource)

  if (isLoading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return (
    <div>
      {data.records.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  )
}
```

### Custom Error Handling

```tsx
function UserListWithErrorHandling() {
  const [userError, setUserError] = useState<string | null>(null)

  const dataSource = useDataSource({
    filters: userFilters,
    dataAdapter: {
      fetchData: async ({ filters }) => {
        try {
          const response = await fetch("/api/users", {
            method: "POST",
            body: JSON.stringify({ filters }),
          })

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`)
          }

          return response.json()
        } catch (error) {
          throw new Error(`Failed to fetch users: ${error.message}`)
        }
      },
    },
  })

  const { data, isLoading, error } = useData(dataSource, {
    onError: (error) => {
      setUserError(error.message)
      // Log to error tracking service
      console.error("User fetch error:", error)
    },
  })

  if (isLoading) return <div>Loading...</div>
  if (error || userError) return <div>Error: {error?.message || userError}</div>

  return (
    <div>
      {data.records.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  )
}
```

### Filter Override

```tsx
function UserListWithOverrides() {
  const dataSource = useDataSource({
    filters: userFilters,
    currentFilters: { department: ["engineering"] },
    dataAdapter: { fetchData: fetchUsers },
  })

  // Override filters for this specific component
  const { data, isLoading } = useData(dataSource, {
    filters: {
      department: ["engineering", "design"], // Override department filter
      status: ["active"], // Add additional filter
    },
  })

  return (
    <div>
      {data.records.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  )
}
```

## Visualization-Specific Patterns

### Card Collection with Grid-Friendly Pagination

```tsx
function CardCollection({ source }) {
  // Override source to ensure grid-friendly pagination
  const adaptedSource = useMemo(
    () => ({
      ...source,
      dataAdapter: {
        ...source.dataAdapter,
        perPage: source.dataAdapter.perPage ?? 24, // Multiple of 2,3,4,6
      },
    }),
    [source]
  )

  const { data, isLoading, paginationInfo, setPage } = useData(adaptedSource)

  return (
    <div>
      <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
        {data.records.map((item) => (
          <Card key={item.id} {...item} />
        ))}
      </div>

      {paginationInfo && (
        <Pagination
          currentPage={paginationInfo.currentPage}
          totalPages={paginationInfo.pagesCount}
          onPageChange={setPage}
        />
      )}
    </div>
  )
}
```

### Table with Row-Optimized Data

```tsx
function TableCollection({ source }) {
  // Override source for table-friendly pagination
  const adaptedSource = useMemo(
    () => ({
      ...source,
      dataAdapter: {
        ...source.dataAdapter,
        perPage: source.dataAdapter.perPage ?? 50, // Higher count for tables
      },
    }),
    [source]
  )

  const { data, isLoading, paginationInfo, setPage } = useData(adaptedSource)

  return (
    <div>
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>Email</th>
            <th>Department</th>
          </tr>
        </thead>
        <tbody>
          {data.records.map((item) => (
            <tr key={item.id}>
              <td>{item.name}</td>
              <td>{item.email}</td>
              <td>{item.department}</td>
            </tr>
          ))}
        </tbody>
      </table>

      {paginationInfo && (
        <Pagination
          currentPage={paginationInfo.currentPage}
          totalPages={paginationInfo.pagesCount}
          onPageChange={setPage}
        />
      )}
    </div>
  )
}
```

## Advanced Patterns

### Data Transformation

```tsx
function TransformedDataList() {
  const dataSource = useDataSource({
    filters: userFilters,
    dataAdapter: { fetchData: fetchUsers },
  })

  const { data, isLoading } = useData(dataSource)

  // Transform data for specific visualization needs
  const transformedData = useMemo(() => {
    return data.records.map((user) => ({
      ...user,
      fullName: `${user.firstName} ${user.lastName}`,
      avatar: user.avatar || generateAvatarUrl(user.id),
    }))
  }, [data.records])

  return (
    <div>
      {transformedData.map((user) => (
        <div key={user.id}>
          <img src={user.avatar} alt={user.fullName} />
          <span>{user.fullName}</span>
        </div>
      ))}
    </div>
  )
}
```

### Conditional Data Fetching

```tsx
function ConditionalDataList({ shouldFetch }) {
  const dataSource = useDataSource(
    {
      filters: userFilters,
      dataAdapter: useMemo(
        () => ({
          fetchData: shouldFetch ? fetchUsers : () => ({ records: [] }),
        }),
        [shouldFetch]
      ),
    },
    [shouldFetch]
  )

  const { data, isLoading } = useData(dataSource)

  if (!shouldFetch) {
    return <div>Data fetching is disabled</div>
  }

  return (
    <div>
      {data.records.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  )
}
```

### Multi-Source Data Combination

```tsx
function CombinedDataList() {
  const usersSource = useDataSource({
    filters: userFilters,
    dataAdapter: { fetchData: fetchUsers },
  })

  const projectsSource = useDataSource({
    filters: projectFilters,
    dataAdapter: { fetchData: fetchProjects },
  })

  const { data: userData, isLoading: usersLoading } = useData(usersSource)
  const { data: projectData, isLoading: projectsLoading } =
    useData(projectsSource)

  const isLoading = usersLoading || projectsLoading

  const combinedData = useMemo(() => {
    return userData.records.map((user) => ({
      ...user,
      projects: projectData.records.filter((project) =>
        project.assignedUsers.includes(user.id)
      ),
    }))
  }, [userData.records, projectData.records])

  return (
    <div>
      {combinedData.map((user) => (
        <div key={user.id}>
          <h3>{user.name}</h3>
          <div>Projects: {user.projects.length}</div>
        </div>
      ))}
    </div>
  )
}
```

## Best Practices

### 1. Handle Loading States Properly

```tsx
function UserList() {
  const { data, isInitialLoading, isLoading, error } = useData(dataSource)

  // Show skeleton during initial load
  if (isInitialLoading) {
    return <UserListSkeleton />
  }

  // Show error state
  if (error) {
    return <ErrorState error={error} />
  }

  return (
    <div>
      {/* Show loading indicator for subsequent loads */}
      {isLoading && !isInitialLoading && <LoadingIndicator />}

      {data.records.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  )
}
```

### 2. Use Memoization for Expensive Operations

```tsx
function OptimizedUserList() {
  const { data, isLoading } = useData(dataSource)

  // Memoize expensive data transformations
  const processedData = useMemo(() => {
    return data.records.map((user) => ({
      ...user,
      searchableText:
        `${user.name} ${user.email} ${user.department}`.toLowerCase(),
    }))
  }, [data.records])

  return (
    <div>
      {processedData.map((user) => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  )
}
```

### 3. Implement Error Boundaries

```tsx
function UserListWithErrorBoundary() {
  return (
    <ErrorBoundary fallback={<ErrorFallback />}>
      <UserList />
    </ErrorBoundary>
  )
}
```

### 4. Optimize Re-renders

```tsx
const UserCard = memo(({ user }) => <div>{user.name}</div>)

function UserList() {
  const { data, isLoading } = useData(dataSource)

  return (
    <div>
      {data.records.map((user) => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  )
}
```

## Related Hooks

- [`useDataSource`](/?path=/docs/hooks-datasource-usedatasource--docs) - For
  creating data sources
- [`useSelectable`](/?path=/docs/hooks-datasource-useselectable--docs) - For
  selection management
- [`useGroups`](/?path=/docs/hooks-datasource-usegroups--docs) - For group state
  management

## Common Patterns

### Loading States

```tsx
const { data, isInitialLoading, isLoading, isLoadingMore } = useData(dataSource)

// isInitialLoading: true only for the first load
// isLoading: true for any loading state
// isLoadingMore: true when loading additional pages (infinite scroll)
```

### Pagination Types

```tsx
// Page-based pagination
if (paginationInfo?.type === "pages") {
  const { currentPage, pagesCount } = paginationInfo
}

// Infinite scroll pagination
if (paginationInfo?.type === "infinite-scroll") {
  const { cursor, hasMore } = paginationInfo
}
```

### Data Organization

```tsx
// Check if data is grouped
if (data.type === "grouped") {
  // Handle grouped data
  data.groups.forEach((group) => {
    console.log(group.key, group.records)
  })
} else {
  // Handle flat data
  data.records.forEach((record) => {
    console.log(record)
  })
}
```
